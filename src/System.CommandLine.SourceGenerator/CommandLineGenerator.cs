using System.Collections.Generic;
using System.CommandLine.SourceGenerator.Common;
using System.CommandLine.SourceGenerator.Models;
using System.CommandLine.SourceGenerator.Extensions;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace System.CommandLine.SourceGenerator;

using Property = KeyValuePair<string, object>;

internal static class CommandLineGenerator
{
    public static IEnumerable<(string HintName, SourceText Source)> Generate(CommandDeclaration command)
    {
        var source = new SourceTextBuilder();

        source.WriteLine("// <auto-generated/>", true);
        source.WriteLine("using global::System.CommandLine.SourceGenerator.Common;");
        source.WriteLine();

        if (!command.TypeSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            source.Write("namespace ", true).WriteLine(command.TypeSymbol.ContainingNamespace.ToFullyQualifiedDisplayString());
            source.OpenBrace();
        }

        GenerateOptionsClassDefinition(command, source);
        source.WriteLine();
        GenerateFactoryClassDefinition(command, source);

        if (!command.TypeSymbol.ContainingNamespace.IsGlobalNamespace)
            source.CloseBrace();

        var hitName = $"{command.TypeSymbol.Name}.g.cs";

        return command.CommandDeclarations
            .SelectMany(Generate)
            .Append((hitName, source.Build()));
    }

    private static void GenerateOptionsClassDefinition(CommandDeclaration command, SourceTextBuilder source)
    {
        var accessibility = ConverToString(command.TypeSymbol.DeclaredAccessibility);

        source.WriteLine($"{accessibility}class {command.OptionsType.Name}", true);
        source.OpenBrace();

        source.WriteLine($"public ICommandHandler<{command.TypeSymbol.ToFullyQualifiedDisplayString(true)}> Handler {{ get; set; }}", true);

        foreach (var subCommand in command.CommandDeclarations)
        {
            var subOptionsType = subCommand.OptionsType.GetQualifiedNameBy(command.TypeSymbol);
            var subOptionsName = subCommand.OptionsType.Name;

            source.WriteLine();
            source.WriteLine($"public {subOptionsType} {subOptionsName} {{ get; set; }}", true);
        }

        source.CloseBrace();
    }

    /*
     <accessibility> static class ~~Factory
     {
         << GenerateCommandFactoryCreateMethod >>
         << GenerateCommandHandlerAdapterClassDefinition >>
     }
     */
    private static void GenerateFactoryClassDefinition(CommandDeclaration command, SourceTextBuilder source)
    {
        var accessibility = ConverToString(command.TypeSymbol.DeclaredAccessibility);

        source.WriteLine($"{accessibility}static class {command.FactoryType.Name}", true);
        source.OpenBrace();

        GenerateCommandFactoryCreateMethod(source, command);
        source.WriteLine();
        GenerateCommandHandlerAdapterClassDefinition(source, command);

        source.CloseBrace();
    }

    /*
     public static RootCommand Create()
     {
         return Create(null);
     }

     public static RootCommand Create(~~Options options)
     {
         <name> = << GenerateCommandCreationCode >>
         return <name>;
     }
     */
    private static void GenerateCommandFactoryCreateMethod(SourceTextBuilder source, CommandDeclaration command)
    {
        var commandType = command is RootCommandDeclaration ? Types.RootCommand : Types.Command;

        source.WriteBlock(
            $$"""
              public static {{commandType}} Create()
              {
                  return Create(null);
              }
              """
            , true);

        source.WriteLine();

        //

        source.WriteLine();

        //

        source.WriteLine($"public static {commandType} Create({command.OptionsType.Name} options)", true);
        source.OpenBrace();

        var commandVariableName = GenerateCommandCreationCode(source, command, commandType);
        source.WriteLine($"return {commandVariableName};", true);

        source.CloseBrace();
    }

    private static string GenerateOptionsCreationCode(SourceTextBuilder source, CommandDeclaration command)
    {
        return GenerateCreationCode(source, new MethodContext(), command);

        static string GenerateCreationCode(SourceTextBuilder source, MethodContext methodContext, CommandDeclaration command)
        {
            var optionsVariableName = methodContext.Declare("options", null);
            var optionsProperties = new Dictionary<string, object>();

            // sub
            foreach (var subCommand in command.CommandDeclarations)
            {
                var subCommandVariableName = GenerateCreationCode(source, methodContext, subCommand);
                optionsProperties[subCommand.OptionsType.Name] = new RawLiteral(subCommandVariableName);
            }

            // main
            if (command.HandlerTypeSymbol is not null)
                optionsProperties["Handler"] = new RawLiteral($"new {command.HandlerTypeSymbol.ToFullyQualifiedDisplayString(true)}()");

            source.Write($"var {optionsVariableName} = ", true);
            WriteClassCreationCode(source, command.OptionsType.Name, Enumerable.Empty<object>(), optionsProperties);

            return optionsVariableName;
        }
    }

    /*
     var symbol = << GenerateSymbolCreationCode >>
     var symbol1 = << GenerateSymbolCreationCode >>
     var symbol2 = << GenerateSymbolCreationCode >>
     var cmd = new Command(..) { .. };
     cmd.AddOption(symbol);
     cmd.AddGlobalOption(symbol1);
     cmd.AddArgument(symbol2);
     */
    private static string GenerateCommandCreationCode(
        SourceTextBuilder source,
        CommandDeclaration command,
        string commandType)
    {
        var methodContext = new MethodContext();

        var symbolVariableNames = command.SymbolDeclarations
            .Select(x => GenerateSymbolCreationCode(source, methodContext, x))
            .ToArray();

        var handlerAdapterVariableName = methodContext.Declare("handlerAdapter", null);

        if (command.HandlerTypeSymbol is not null)
        {
            var handlerVariableName = methodContext.Declare("handler", null);
            var handlerAdapterArgs = string.Join(", ", symbolVariableNames.Prepend(handlerVariableName));

            source.WriteBlock(
                $"""
                 var {handlerVariableName} = options.Handler;
                 if ({handlerVariableName} == null)
                     {handlerVariableName} = new {command.HandlerTypeSymbol.ToFullyQualifiedDisplayString(true)}();
                 var {handlerAdapterVariableName} = new {command.CommandHandlerAdapterType.Name}({handlerAdapterArgs});
                 """,
                true);

            source.WriteLine();
        }
        else
        {
            var handlerAdapterArgs = string.Join(", ", symbolVariableNames.Prepend("options.Handler"));
            source.WriteLine($"var {handlerAdapterVariableName} = new {command.CommandHandlerAdapterType.Name}({handlerAdapterArgs});", true);
        }

        // var cmd = new Command(..);
        var commandVariableName = methodContext.Declare("cmd", command);
        source.Write($"var {commandVariableName} = ", true);

        var commandProperties = new Dictionary<string, object>(command.Attribute.NamedArguments);
        commandProperties.Remove(nameof(CommandAttribute.Aliases));
        commandProperties.Remove(nameof(CommandAttribute.Subcommands));
        commandProperties[nameof(Command.Handler)] = new RawLiteral(handlerAdapterVariableName);

        WriteClassCreationCode(
            source,
            commandType,
            command.Attribute.ConstructorArguments,
            commandProperties
        );

        if (command.Attribute.Value is { Aliases: { Length: > 0 } aliases })
        {
            foreach (var alias in aliases)
            {
                var aliasLiteral = ConvertToLiteral(alias);
                source.WriteLine($"{commandVariableName}.{nameof(Command.AddAlias)}({aliasLiteral});", true);
            }
        }

        // cmd.AddOption(symbol);
        // cmd.AddGlobalOption(symbol1);
        // cmd.AddArgument(symbol2);
        // ..
        foreach (var symbolVariableName in symbolVariableNames)
        {
            var addMethod = methodContext.Variables[symbolVariableName] switch
            {
                ArgumentDeclaration => nameof(Command.AddArgument),
                OptionDeclaration { Attribute.Value: GlobalOptionAttribute } => nameof(Command.AddGlobalOption),
                OptionDeclaration => nameof(Command.AddOption),
                _ => throw new ArgumentOutOfRangeException()
            };

            source.WriteLine($"{commandVariableName}.{addMethod}({symbolVariableName});", true);
        }

        // cmd.AddCommand( SubCommandFactory.Create() );
        foreach (var subCommand in command.CommandDeclarations)
        {
            var subFactoryType = subCommand.FactoryType.GetQualifiedNameBy(command.TypeSymbol);
            var subOptionsAccessor = $"options.{subCommand.OptionsType.Name}";

            source.WriteBlock(
                $$"""
                  if (options != null && {{subOptionsAccessor}} != null)
                  {
                      {{commandVariableName}}.{{nameof(Command.AddCommand)}}({{subFactoryType}}.Create({{subOptionsAccessor}}));
                  }
                  else
                  {
                      {{commandVariableName}}.{{nameof(Command.AddCommand)}}({{subFactoryType}}.Create());
                  }
                  """,
                true);

            source.WriteLine();
        }

        return commandVariableName;
    }

    private static string GenerateSymbolCreationCode(
        SourceTextBuilder source,
        MethodContext methodContext,
        IPropertyBasedSymbolDeclaration symbol)
    {
        var symbolVariableName = methodContext.Declare("symbol", symbol);
        source.Write($"var {symbolVariableName} = ", true);

        switch (symbol)
        {
            case ArgumentDeclaration argument:
            {
                // new Argument<..>(..) { .. };
                IEnumerable<Property> properties = GetArgumentProperties(argument.Attribute, argument.Arity);
                var type = $"{Types.Argument}<{argument.PropertySymbol.Type.ToFullyQualifiedDisplayString(true)}>";

                WriteClassCreationCode(
                    source,
                    type,
                    argument.Attribute.ConstructorArguments,
                    properties
                );

                return symbolVariableName;
            }

            case OptionDeclaration option:
            {
                // new Option<..>(..) { .. };
                IEnumerable<Property> properties = GetOptionProperties(option.Attribute, option.Arity);
                var type = $"{Types.Option}<{option.PropertySymbol.Type.ToFullyQualifiedDisplayString(true)}>";

                WriteClassCreationCode(
                    source,
                    type,
                    option.Attribute.ConstructorArguments,
                    properties
                );

                // symbol.AddAlias("..");
                // ..
                if (option.Attribute.Value is { Aliases: { Length: > 0 } aliases })
                {
                    foreach (var alias in aliases)
                    {
                        var aliasLiteral = ConvertToLiteral(alias);
                        source.WriteLine($"{symbolVariableName}.{nameof(Option.AddAlias)}({aliasLiteral});", true);
                    }
                }

                return symbolVariableName;
            }

            default:
                throw new ArgumentOutOfRangeException(nameof(symbol));
        }
    }

    private static IEnumerable<Property> GetArgumentProperties(IAttributeDeclaration<ArgumentAttribute> attr, ArgumentArityAttribute arity)
    {
        // Argument
        if (arity != null)
        {
            yield return new Property(nameof(Argument.Arity), arity);
        }
        else if (attr.Value.ArityInternal.HasValue)
        {
            yield return new Property(nameof(Argument.Arity), attr.Value.ArityInternal.Value);
        }

        foreach (Property prop in attr.NamedArguments.Where(x => x.Key != nameof(Argument.Arity)))
            yield return prop;
    }

    private static IEnumerable<Property> GetOptionProperties(IAttributeDeclaration<OptionAttribute> attr, ArgumentArityAttribute arity)
    {
        // Option
        if (arity != null)
        {
            // from ArgumentArityAttribute
            yield return new Property(nameof(Option.Arity), arity);
        }
        else if (attr.Value.ArityInternal.HasValue)
        {
            // from OptionAttribute
            yield return new Property(nameof(Option.Arity), attr.Value.ArityInternal.Value);
        }

        foreach (Property prop in attr.NamedArguments
                     .Where(x => x.Key != nameof(Option.Arity) && x.Key != nameof(Option.Aliases)))
        {
            yield return prop;
        }
    }

    private static void GenerateCommandHandlerAdapterClassDefinition(SourceTextBuilder source, CommandDeclaration command)
    {
        source.WriteLine($"private sealed class {command.CommandHandlerAdapterType.Name} : {Types.ICommandHandler}", true);
        source.OpenBrace();

        // private readonly ICommandHandler<{Command}> _commandHandler;
        source.WriteLine($"private readonly ICommandHandler<{command.TypeSymbol.ToFullyQualifiedDisplayString(true)}> _commandHandler;", true);

        // private readonly IValueDescriptor<..> _v0;
        // private readonly IValueDescriptor<..> _v1;
        // ..
        var symbolFields = command.SymbolDeclarations
            .Select(x => new
            {
                PropertyName = x.PropertySymbol.Name,
                FieldName = $"_symbol{x.PropertySymbol.Name}",
                ArgumentName = $"symbol{x.PropertySymbol.Name}",
                Type = x.PropertySymbol.Type.ToFullyQualifiedDisplayString(true)
            })
            .ToArray();

        foreach (var symbolField in symbolFields)
            source.WriteLine($"private readonly {Types.IValueDescriptor}<{symbolField.Type}> {symbolField.FieldName};", true);

        source.WriteLine();

        /*
         public ..CommandHandler(
            ICommandHandler<{Command}> commandHandler,
             IValueDescriptor<..> symbolXX,
             IValueDescriptor<..> symbolXX,
             ..)
         {
             _symbolXX = symbolXX;
             _symbolXX = symbolXX;
             ..
         }
         */
        var ctorArguments = symbolFields
            .Select(symbolField => $"{Types.IValueDescriptor}<{symbolField.Type}> {symbolField.ArgumentName}")
            .Prepend($"ICommandHandler<{command.TypeSymbol.ToFullyQualifiedDisplayString(true)}> commandHandler")
            .ToArray();

        if (ctorArguments.Length == 1)
        {
            source.WriteLine($"public {command.CommandHandlerAdapterType.Name}({ctorArguments[0]})", true);
        }
        else
        {
            source.WriteLine($"public {command.CommandHandlerAdapterType.Name}(", true);

            for (int i = 0; i < ctorArguments.Length; i++)
            {
                if (i > 0)
                    source.WriteLine(",");

                source.Indent(1).Write(ctorArguments[i]);
            }

            source.WriteLine(")");
        }

        source.OpenBrace();

        source.WriteLine("_commandHandler = commandHandler;", true);

        foreach (var symbolField in symbolFields)
            source.WriteLine($"{symbolField.FieldName} = {symbolField.ArgumentName};", true);

        source.CloseBrace();
        source.WriteLine();

        /*
         int Invoke(InvocationContext context)
         {
             return InvokeAsync(context).Result;
         }
         */
        source.WriteBlock(
            $$"""
              public int Invoke({{Types.InvocationContext}} context)
              {
                  return InvokeAsync(context).Result;
              }
              """, true);

        source.WriteLine();
        source.WriteLine();

        /*
         public Task<int> InvokeAsync(InvocationContext context)
         {
             var command = new ~~Command
             {
                 XX = ValueDesriptorHelper.GetValueForHandlerParameter<T>(_symbolXX),
                 XX = ValueDesriptorHelper.GetValueForHandlerParameter<T>(_symbolXX),
                 ..
             };

             var handler = new ~~CommandHandler();

             handler.InvokeAsync(command);
         }
        */
        source.WriteLine($"public {Types.Task}<int> InvokeAsync({Types.InvocationContext} context)", true);

        source.OpenBrace();

        source.Write("var command = ", true);

        WriteClassCreationCode(
            source,
            command.TypeSymbol.ToFullyQualifiedDisplayString(true),
            Enumerable.Empty<object>(),
            symbolFields.ToDictionary(
                x => x.PropertyName,
                x => (object)new RawLiteral($"{Types.ValueDesriptorHelper}.GetValueForHandlerParameter<{x.Type}>({x.FieldName}, context)")
            )
        );

        source.WriteLine("return _commandHandler.InvokeAsync(command);", true);

        source.CloseBrace(); // InvokeAsync
        source.CloseBrace(); // class
    }

    private static void WriteClassCreationCode(
        SourceTextBuilder source,
        string classType,
        IEnumerable<object> arguments,
        IEnumerable<Property> properties)
    {
        source
            .Write($"new {classType}(")
            .WriteJoin(", ", arguments.Select(ConvertToLiteral))
            .Write(")");

        var i = 0;

        foreach (Property property in properties)
        {
            if (i++ == 0)
            {
                source.WriteLine();
                source.OpenBrace();
            }
            else
            {
                source.WriteLine(",");
            }

            source.Write($"{property.Key} = {ConvertToLiteral(property.Value)}", true);
        }

        if (i > 0)
        {
            source.WriteLine();
            source.CloseBrace(false);
        }

        source.WriteLine(";");
    }

    private static string ConvertToLiteral(object value)
    {
        switch (value)
        {
            case RawLiteral literal:
                return literal.Value;

            case null:
                return "null";

            case string str:
                return ConvertToStringLiteral(str);

            case ArgumentArityEnum arityEnum:
                return ConvertToArgumentArityLiteral(arityEnum);

            case ArgumentArityAttribute arity:
                return ConvertToArgumentArityLiteral(arity);

            case bool boolValue:
                return boolValue.ToString().ToLowerInvariant();

            default:
                throw new NotSupportedException($"Unsupported literal: {value}");
        }
    }

    private static string ConvertToArgumentArityLiteral(ArgumentArityAttribute arity)
    {
        return $"new {Types.ArgumentArity}({arity.MinimumNumberOfValues}, {arity.MaximumNumberOfValues})";
    }

    private static string ConvertToArgumentArityLiteral(ArgumentArityEnum arity)
    {
        return arity switch
        {
            ArgumentArityEnum.Zero => $"{Types.ArgumentArity}.Zero",
            ArgumentArityEnum.ZeroOrOne => $"{Types.ArgumentArity}.ZeroOrOne",
            ArgumentArityEnum.ExactlyOne => $"{Types.ArgumentArity}.ExactlyOne",
            ArgumentArityEnum.ZeroOrMore => $"{Types.ArgumentArity}.ZeroOrMore",
            ArgumentArityEnum.OneOrMore => $"{Types.ArgumentArity}.OneOrMore",
            _ => throw new ArgumentOutOfRangeException(nameof(arity), arity, null)
        };
    }

    private static string ConvertToStringLiteral(string value)
    {
        if (value is null)
            return "null";

        if (value.Length == 0)
            return "\"\"";

        var escapedValue = value
            .Replace(@"\", @"\\")
            .Replace("\"", "\\\"")
            .Replace("\0", "\\0")
            .Replace("\a", "\\a")
            .Replace("\b", "\\b")
            .Replace("\f", "\\f")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\v", "\\v");

        return $"\"{escapedValue}\"";
    }

    private static string ConverToString(Accessibility accessibility) => accessibility switch
    {
        Accessibility.NotApplicable => string.Empty,
        Accessibility.Private => "private ",
        Accessibility.ProtectedAndInternal => "private protected ",
        Accessibility.Protected => "protected ",
        Accessibility.Internal => "internal ",
        Accessibility.ProtectedOrInternal => "protected internal ",
        Accessibility.Public => "public ",
        _ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null)
    };

    private readonly struct RawLiteral
    {
        public string Value { get; }

        public RawLiteral(string value)
        {
            Value = value;
        }
    }

    private sealed class MethodContext
    {
        public Dictionary<string, object> Variables { get; } = new();

        public string Declare(string name, object value)
        {
            var declaredName = name;
            var n = 0;

            while (Variables.ContainsKey(declaredName))
                declaredName = $"{name}{++n}";

            Variables.Add(declaredName, value);

            return declaredName;
        }
    }

    private static class Types
    {
        public const string RootCommand = "global::System.CommandLine.RootCommand";
        public const string Command = "global::System.CommandLine.Command";
        public const string Option = "global::System.CommandLine.Option";
        public const string Argument = "global::System.CommandLine.Argument";
        public const string ArgumentArity = "global::System.CommandLine.ArgumentArity";

        public const string ICommandHandler = "global::System.CommandLine.Invocation.ICommandHandler";
        public const string InvocationContext = "global::System.CommandLine.Invocation.InvocationContext";

        public const string IValueDescriptor = "global::System.CommandLine.Binding.IValueDescriptor";

        public const string Task = "global::System.Threading.Tasks.Task";

        public const string ValueDesriptorHelper = "ValueDesriptorHelper";
    }
}
