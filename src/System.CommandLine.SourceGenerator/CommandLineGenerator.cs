using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.CommandLine.SourceGenerator.Common;
using System.CommandLine.SourceGenerator.Models;
using System.CommandLine.SourceGenerator.Extensions;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace System.CommandLine.SourceGenerator;

using Property = KeyValuePair<string, object>;

internal static class CommandLineGenerator
{
    public static IEnumerable<(string HintName, SourceText Source)> Generate(CommandDeclaration command)
    {
        var source = new SourceTextBuilder();

        source.WriteLine("// <auto-generated/>", true);
        source.WriteLine("using global::System.CommandLine.SourceGenerator.Common;");
        source.WriteLine();

        if (command.TypeSymbol.ContainingNamespace.IsGlobalNamespace)
        {
            GenerateFactoryClassDefinition(command, source);
        }
        else
        {
            source.Write("namespace ", true).WriteLine(command.TypeSymbol.ContainingNamespace.ToFullyQualifiedDisplayString());
            source.OpenBrace();
            GenerateFactoryClassDefinition(command, source);
            source.CloseBrace();
        }

        var hitName = $"{command.TypeSymbol.Name}.g.cs";

        return command.CommandDeclarations
            .SelectMany(Generate)
            .Append((hitName, source.Build()));
    }

    /*
     <accessibility> static class ~~Factory
     {
         << GenerateCommandFactoryCreateMethod >>
         << GenerateCommandHandlerClassDefinition >>
     }
     */
    private static void GenerateFactoryClassDefinition(CommandDeclaration command, SourceTextBuilder source)
    {
        var className = $"{command.TypeSymbol.Name}Factory";
        var accessibility = ConverToString(command.TypeSymbol.DeclaredAccessibility);

        source.WriteLine($"{accessibility}static class {className}", true);
        source.OpenBrace();

        GenerateCommandFactoryCreateMethod(source, command);

        if (command.HandlerTypeSymbol is not null)
        {
            source.WriteLine();
            GenerateCommandHandlerClassDefinition(source, command);
        }

        source.CloseBrace();
    }

    /*
     public static RootCommand Create()
     {
         <name> = << GenerateCommandCreationCode >>
         return <name>;
     }
     */
    private static void GenerateCommandFactoryCreateMethod(SourceTextBuilder source, CommandDeclaration command)
    {
        var commandType = command is RootCommandDeclaration ? Types.RootCommand : Types.Command;

        if (command.TypeSymbol.IsGenericType)
        {
            var typeParamNames = string.Join(", ", command.TypeSymbol.TypeParameters.Select(x => x.Name));

            source.Write($"public static {commandType} Create<{typeParamNames}>()", true);
            WriteGenericConstraint(source, command.TypeSymbol.TypeParameters);
        }
        else
        {
            source.WriteLine($"public static {commandType} Create()", true);
        }

        source.OpenBrace();

        var methodContext = new MethodContext();
        var commandVariableName = GenerateCommandCreationCode(source, methodContext, command, commandType);

        source.WriteLine($"return {commandVariableName};", true);

        source.CloseBrace();
    }

    /*
     var symbol = << GenerateSymbolCreationCode >>
     var symbol1 = << GenerateSymbolCreationCode >>
     var symbol2 = << GenerateSymbolCreationCode >>
     var cmd = new Command(..) { .. };
     cmd.AddOption(symbol);
     cmd.AddGlobalOption(symbol1);
     cmd.AddArgument(symbol2);
     */
    private static string GenerateCommandCreationCode(
        SourceTextBuilder source,
        MethodContext methodContext,
        CommandDeclaration command,
        string commandType)
    {
        var symbolVariableNames = command.SymbolDeclarations
            .Select(x => GenerateSymbolCreationCode(source, methodContext, x))
            .ToArray();

        // var cmd = new Command(..);
        var commandVariableName = methodContext.Declare("cmd", command);
        source.Write($"var {commandVariableName} = ", true);

        var commandProperties = new Dictionary<string, object>(command.Attribute.NamedArguments);
        commandProperties.Remove(nameof(Command.Aliases));

        if (command.HandlerTypeSymbol is not null)
        {
            var commandHandlerArgs = string.Join(", ", symbolVariableNames);
            var commandHandlerTypeParamNames = string.Join(", ", command.TypeSymbol.TypeParameters.Select(x => x.Name));

            var commandHandlerCreationCode = command.TypeSymbol.IsGenericType
                ? $"new {command.TypeSymbol.Name}CommandHandler<{commandHandlerTypeParamNames}>({commandHandlerArgs})"
                : $"new {command.TypeSymbol.Name}CommandHandler({commandHandlerArgs})";

            commandProperties[nameof(Command.Handler)] = new RawLiteral(commandHandlerCreationCode);
        }

        WriteClassCreationCode(
            source,
            commandType,
            command.Attribute.ConstructorArguments,
            commandProperties
        );

        if (command.Attribute.Value is { Aliases: { Length: > 0 } aliases })
        {
            foreach (var alias in aliases)
            {
                var aliasLiteral = ConvertToLiteral(alias);
                source.WriteLine($"{commandVariableName}.{nameof(Command.AddAlias)}({aliasLiteral});", true);
            }
        }

        // cmd.AddOption(symbol);
        // cmd.AddGlobalOption(symbol1);
        // cmd.AddArgument(symbol2);
        // ..
        foreach (var symbolVariableName in symbolVariableNames)
        {
            var addMethod = methodContext.Variables[symbolVariableName] switch
            {
                ArgumentDeclaration => nameof(Command.AddArgument),
                OptionDeclaration { Attribute.Value: GlobalOptionAttribute } => nameof(Command.AddGlobalOption),
                OptionDeclaration => nameof(Command.AddOption),
                _ => throw new ArgumentOutOfRangeException()
            };

            source.WriteLine($"{commandVariableName}.{addMethod}({symbolVariableName});", true);
        }

        // cmd.AddCommand( SubCommandFactory.Create() );
        foreach (var subCommand in command.CommandDeclarations)
        {
            var subFactoryType = $"{subCommand.TypeSymbol.Name}Factory";

            if (!subCommand.TypeSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                var subFactoryNamespace = subCommand.TypeSymbol.ContainingNamespace.ToFullyQualifiedDisplayString(true);
                subFactoryType = $"{subFactoryNamespace}.{subFactoryType}";
            }

            source.WriteLine($"{commandVariableName}.{nameof(Command.AddCommand)}({subFactoryType}.Create());", true);
        }

        return commandVariableName;
    }

    private static string GenerateSymbolCreationCode(
        SourceTextBuilder source,
        MethodContext methodContext,
        IPropertyBasedSymbolDeclaration symbol)
    {
        var symbolVariableName = methodContext.Declare("symbol", symbol);
        source.Write($"var {symbolVariableName} = ", true);

        switch (symbol)
        {
            case ArgumentDeclaration argument:
            {
                // new Argument<..>(..) { .. };
                IEnumerable<Property> properties = GetArgumentProperties(argument.Attribute, argument.Arity);
                var type = $"{Types.Argument}<{argument.PropertySymbol.Type.ToFullyQualifiedDisplayString(true)}>";

                WriteClassCreationCode(
                    source,
                    type,
                    argument.Attribute.ConstructorArguments,
                    properties
                );

                return symbolVariableName;
            }

            case OptionDeclaration option:
            {
                // new Option<..>(..) { .. };
                IEnumerable<Property> properties = GetOptionProperties(option.Attribute, option.Arity);
                var type = $"{Types.Option}<{option.PropertySymbol.Type.ToFullyQualifiedDisplayString(true)}>";

                WriteClassCreationCode(
                    source,
                    type,
                    option.Attribute.ConstructorArguments,
                    properties
                );

                // symbol.AddAlias("..");
                // ..
                if (option.Attribute.Value is { Aliases: { Length: > 0 } aliases })
                {
                    foreach (var alias in aliases)
                    {
                        var aliasLiteral = ConvertToLiteral(alias);
                        source.WriteLine($"{symbolVariableName}.{nameof(Option.AddAlias)}({aliasLiteral});", true);
                    }
                }

                return symbolVariableName;
            }

            default:
                throw new ArgumentOutOfRangeException(nameof(symbol));
        }
    }

    private static IEnumerable<Property> GetArgumentProperties(IAttributeDeclaration<ArgumentAttribute> attr, ArgumentArityAttribute arity)
    {
        // Argument
        if (arity != null)
        {
            yield return new Property(nameof(Argument.Arity), arity);
        }
        else if (attr.Value.ArityInternal.HasValue)
        {
            yield return new Property(nameof(Argument.Arity), attr.Value.ArityInternal.Value);
        }

        foreach (Property prop in attr.NamedArguments.Where(x => x.Key != nameof(Argument.Arity)))
            yield return prop;
    }

    private static IEnumerable<Property> GetOptionProperties(IAttributeDeclaration<OptionAttribute> attr, ArgumentArityAttribute arity)
    {
        // Option
        if (arity != null)
        {
            // from ArgumentArityAttribute
            yield return new Property(nameof(Option.Arity), arity);
        }
        else if (attr.Value.ArityInternal.HasValue)
        {
            // from OptionAttribute
            yield return new Property(nameof(Option.Arity), attr.Value.ArityInternal.Value);
        }

        foreach (Property prop in attr.NamedArguments
                     .Where(x => x.Key != nameof(Option.Arity) && x.Key != nameof(Option.Aliases)))
        {
            yield return prop;
        }
    }

    private static void GenerateCommandHandlerClassDefinition(SourceTextBuilder source, CommandDeclaration command)
    {
        var typeParams = command.TypeSymbol.IsGenericType
            ? $"<{string.Join(", ", command.TypeSymbol.TypeParameters.Select(x => x.Name))}>"
            : null;

        var className = $"{command.TypeSymbol.Name}CommandHandler";

        if (command.TypeSymbol.IsGenericType)
        {
            source.Write($"private sealed class {className}{typeParams} : {Types.ICommandHandler}", true);
            WriteGenericConstraint(source, command.TypeSymbol.TypeParameters);
        }
        else
        {
            source.WriteLine($"private sealed class {className} : {Types.ICommandHandler}", true);
        }

        source.OpenBrace();

        // private readonly IValueDescriptor<..> _v0;
        // private readonly IValueDescriptor<..> _v1;
        // ..
        var symbolFields = command.SymbolDeclarations
            .Select(x => new
            {
                PropertyName = x.PropertySymbol.Name,
                FieldName = $"_symbol{x.PropertySymbol.Name}",
                ArgumentName = $"symbol{x.PropertySymbol.Name}",
                Type = x.PropertySymbol.Type.ToFullyQualifiedDisplayString(true)
            })
            .ToArray();

        if (symbolFields.Length > 0)
        {
            foreach (var symbolField in symbolFields)
                source.WriteLine($"private readonly {Types.IValueDescriptor}<{symbolField.Type}> {symbolField.FieldName};", true);

            source.WriteLine();
        }

        /*
         public ..CommandHandler(
             IValueDescriptor<..> symbolXX,
             IValueDescriptor<..> symbolXX,
             ..)
         {
             _symbolXX = symbolXX;
             _symbolXX = symbolXX;
             ..
         }
         */
        if (symbolFields.Length > 0)
        {
            source.WriteLine($"public {className}(", true);

            for (int i = 0; i < symbolFields.Length; i++)
            {
                if (i > 0)
                    source.WriteLine(",");

                source.Indent(1).Write($"{Types.IValueDescriptor}<{symbolFields[i].Type}> {symbolFields[i].ArgumentName}");
            }

            source.WriteLine(")");

            source.OpenBrace();

            foreach (var symbolField in symbolFields)
                source.WriteLine($"{symbolField.FieldName} = {symbolField.ArgumentName};", true);

            source.CloseBrace();
            source.WriteLine();
        }

        /*
         int Invoke(InvocationContext context)
         {
             return InvokeAsync(context).Result;
         }
         */
        source.WriteBlock(
            $$"""
              public int Invoke({{Types.InvocationContext}} context)
              {
                  return InvokeAsync(context).Result;
              }
              """, true);

        source.WriteLine();
        source.WriteLine();

        /*
         public Task<int> InvokeAsync(InvocationContext context)
         {
             var command = new ~~Command
             {
                 XX = ValueDesriptorHelper.GetValueForHandlerParameter<T>(_symbolXX),
                 XX = ValueDesriptorHelper.GetValueForHandlerParameter<T>(_symbolXX),
                 ..
             };

             var handler = new ~~CommandHandler();

             handler.InvokeAsync(command);
         }
        */
        source.WriteLine($"public {Types.Task}<int> InvokeAsync({Types.InvocationContext} context)", true);

        source.OpenBrace();

        source.Write("var command = ", true);

        WriteClassCreationCode(
            source,
            $"{command.TypeSymbol.ToFullyQualifiedDisplayString(true)}{typeParams}",
            Enumerable.Empty<object>(),
            symbolFields.ToDictionary(
                x => x.PropertyName,
                x => (object)new RawLiteral($"{Types.ValueDesriptorHelper}.GetValueForHandlerParameter<{x.Type}>({x.FieldName}, context)")
            )
        );

        source.WriteLine($"var handler = new {command.HandlerTypeSymbol.ToFullyQualifiedDisplayString(true)}{typeParams}();", true);
        source.WriteLine("return handler.InvokeAsync(command);", true);

        source.CloseBrace(); // InvokeAsync
        source.CloseBrace(); // class
    }

    private static void WriteClassCreationCode(
        SourceTextBuilder source,
        string classType,
        IEnumerable<object> arguments,
        IEnumerable<Property> properties)
    {
        source
            .Write($"new {classType}(")
            .WriteJoin(", ", arguments.Select(ConvertToLiteral))
            .Write(")");

        var i = 0;

        foreach (Property property in properties)
        {
            if (i++ == 0)
            {
                source.WriteLine();
                source.OpenBrace();
            }
            else
            {
                source.WriteLine(",");
            }

            source.Write($"{property.Key} = {ConvertToLiteral(property.Value)}", true);
        }

        if (i > 0)
        {
            source.WriteLine();
            source.CloseBrace(false);
        }

        source.WriteLine(";");
    }

    private static void WriteGenericConstraint(SourceTextBuilder source, IEnumerable<ITypeParameterSymbol> typeParameters)
    {
        ITypeParameterSymbol[] constraintParameters = typeParameters
            .Where(x =>
                x is { ConstraintTypes.Length: > 0 } ||
                x.HasConstructorConstraint ||
                x.HasNotNullConstraint ||
                x.HasReferenceTypeConstraint ||
                x.HasUnmanagedTypeConstraint ||
                x.HasValueTypeConstraint
            )
            .ToArray();

        switch (constraintParameters.Length)
        {
            case 0:
                return;

            case 1:
                source.Write(" ");
                break;
        }

        foreach (var typeParameter in constraintParameters)
        {
            if (constraintParameters.Length >= 2)
            {
                source.WriteLine();
                source.Indent(1);
            }

            source.Write($"where {typeParameter.Name} : ");
            source.WriteJoin(", ", GetConstraintTokens(typeParameter));
        }

        source.WriteLine();

        return;

        static IEnumerable<string> GetConstraintTokens(ITypeParameterSymbol typeParameter)
        {
            if (typeParameter.HasNotNullConstraint)
                yield return "notnull";
            else if (typeParameter.HasReferenceTypeConstraint)
                yield return "class";
            else if (typeParameter.HasUnmanagedTypeConstraint)
                yield return "unmanaged";
            else if (typeParameter.HasValueTypeConstraint)
                yield return "struct";

            foreach (var constraintType in typeParameter.ConstraintTypes.Select(x => x.ToFullyQualifiedDisplayString(true)))
                yield return constraintType;

            if (typeParameter.HasConstructorConstraint)
                yield return "new()";
        }
    }

    private static string ConvertToLiteral(object value)
    {
        switch (value)
        {
            case RawLiteral literal:
                return literal.Value;

            case null:
                return "null";

            case string str:
                return ConvertToStringLiteral(str);

            case ArgumentArityEnum arityEnum:
                return ConvertToArgumentArityLiteral(arityEnum);

            case ArgumentArityAttribute arity:
                return ConvertToArgumentArityLiteral(arity);

            case bool boolValue:
                return boolValue.ToString().ToLowerInvariant();

            default:
                throw new NotSupportedException($"Unsupported literal: {value}");
        }
    }

    private static string ConvertToArgumentArityLiteral(ArgumentArityAttribute arity)
    {
        return $"new {Types.ArgumentArity}({arity.MinimumNumberOfValues}, {arity.MaximumNumberOfValues})";
    }

    private static string ConvertToArgumentArityLiteral(ArgumentArityEnum arity)
    {
        return arity switch
        {
            ArgumentArityEnum.Zero => $"{Types.ArgumentArity}.Zero",
            ArgumentArityEnum.ZeroOrOne => $"{Types.ArgumentArity}.ZeroOrOne",
            ArgumentArityEnum.ExactlyOne => $"{Types.ArgumentArity}.ExactlyOne",
            ArgumentArityEnum.ZeroOrMore => $"{Types.ArgumentArity}.ZeroOrMore",
            ArgumentArityEnum.OneOrMore => $"{Types.ArgumentArity}.OneOrMore",
            _ => throw new ArgumentOutOfRangeException(nameof(arity), arity, null)
        };
    }

    private static string ConvertToStringLiteral(string value)
    {
        if (value is null)
            return "null";

        if (value.Length == 0)
            return "\"\"";

        var escapedValue = value
            .Replace(@"\", @"\\")
            .Replace("\"", "\\\"")
            .Replace("\0", "\\0")
            .Replace("\a", "\\a")
            .Replace("\b", "\\b")
            .Replace("\f", "\\f")
            .Replace("\n", "\\n")
            .Replace("\r", "\\r")
            .Replace("\t", "\\t")
            .Replace("\v", "\\v");

        return $"\"{escapedValue}\"";
    }

    private static string ConverToString(Accessibility accessibility) => accessibility switch
    {
        Accessibility.NotApplicable => string.Empty,
        Accessibility.Private => "private ",
        Accessibility.ProtectedAndInternal => "private protected ",
        Accessibility.Protected => "protected ",
        Accessibility.Internal => "internal ",
        Accessibility.ProtectedOrInternal => "protected internal ",
        Accessibility.Public => "public ",
        _ => throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null)
    };

    private readonly struct RawLiteral
    {
        public string Value { get; }

        public RawLiteral(string value)
        {
            Value = value;
        }
    }

    private sealed class MethodContext
    {
        public Dictionary<string, object> Variables { get; } = new();

        public string Declare(string name, object value)
        {
            var declaredName = name;
            var n = 0;

            while (Variables.ContainsKey(declaredName))
                declaredName = $"{name}{++n}";

            Variables.Add(declaredName, value);

            return declaredName;
        }
    }

    private static class Types
    {
        public const string RootCommand = "global::System.CommandLine.RootCommand";
        public const string Command = "global::System.CommandLine.Command";
        public const string Option = "global::System.CommandLine.Option";
        public const string Argument = "global::System.CommandLine.Argument";
        public const string ArgumentArity = "global::System.CommandLine.ArgumentArity";

        public const string ICommandHandler = "global::System.CommandLine.Invocation.ICommandHandler";
        public const string InvocationContext = "global::System.CommandLine.Invocation.InvocationContext";

        public const string IValueDescriptor = "global::System.CommandLine.Binding.IValueDescriptor";

        public const string Task = "global::System.Threading.Tasks.Task";

        public const string ValueDesriptorHelper = "ValueDesriptorHelper";
    }
}
